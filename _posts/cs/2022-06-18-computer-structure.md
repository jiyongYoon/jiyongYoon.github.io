---
title: "컴퓨터구조"
layout: single
categories: cs
typora-root-url: ..\..\images\
toc: true
---

## 1)  컴퓨터 3대 구성요소

1) 컴퓨터 시스템: 하드웨어 + 소프트웨어

   - 폰노이만 구조(현재 컴퓨터 구조)

     - CPU, 메모리, 프로그램 으로 구성되어 있음.
     - 저장매체에 있는 것을 메모리에 올려놓고 CPU가 그걸 처리하는 방식.
     - 예전 컴퓨터 방식에 비해 구성이 효율적임(범용적임). 소프트웨어만 교체하면 하드웨어 교체 없이 다양한 프로그램 및 작업이 가능하기 때문.

     ![ph](..\..\images\ph.png)

2. 컴퓨터 3대 주요 구성요소
   - CPU(중앙처리장치): 연산, 제어
   - MEMORY(메모리): 코드와 데이터를 저장하는 장치
     - 주기억장치: 속도는 빠르지만 전원이 꺼지면 날아가는 메모리(레지스터, 캐쉬, DRAM 등)
     - 보조기억장치: 속도는 느리지만 전원이 없어도 저장되는 메모리(HDD, SSD 등)
   - IO DEVICES(입출력장치)
3. 그 외 구성요소
   - BUS(버스): 각 요소들을 연결해주는 장치. 메인보드 칩셋에서 지원.



## 2) 비트와 게이트

: 컴퓨터는 전기 OFF(0), ON(1) 두가지로 작동함. 이 두가지로 숫자나 문자를 표현해야 하고, 연산을 해야함.

### 1) 논리연산

- AND & OR

![and&or](..\..\images\and&or.PNG)

- NOT

![not](..\..\images\not.PNG)

- NAND & NOR

![nand&nor](..\..\images\nand&nor.PNG)

- 부울대수식

![부울대수식](..\..\images\부울대수식.png)

### 2) 가산

- 반가산기: 두 bit를 덧셈하는 가산기. <br>이진수 덧셈을 표현한다고 가정하면<br> ![hadder](..\..\images\hadder.PNG) <br>이런 결과가 나와야 함. (+자릿수 1을 더하는 것을 carry라고 함) 이런 결과를 만들기 위한 회로 구성을 고민한다면

  ![11](..\..\images\11.PNG) ![22](..\..\images\22.PNG)

  첫째자리는 XOR Gate, 둘째자리는 AND Gate를 사용하면 계산이 가능함. <br>====> 1bit끼리의 계산을 통해 이진수 덧셈을 할 수 있게 됨.<br>

- 전가산기: 두 bit 외에 carry까지 계산할 수 있음.<br>![fadder](..\..\images\fadder.png)<br>

- n비트 가산기: 전가산기 n개를 연결해서 조합하면 n-bit 계산이 가능해짐.<br>**====> 이러한 회로구성을 계속 붙여가며 연산, 데이터 저장 등이 가능해짐!!!**

**윈도우 32bit와 64bit?* - 데이터 처리단위가 32bit, 64bit라는 뜻.

**클럭?* - 가산기가 작동할 때 한 동작을 하기 위해 스위치들이 움직이는 동작(On&Off-One-Cycle)이 필요한데, 그 동작이 1Hz라고 할 수 있음. 즉, CPU가 해당 동작을 1초에 몇번하는지를 나타내는 숫자. ex) 2.1GHz = 2,100MHz = 2,100,000,000Hz = 1초에 이만큼 움직이며 가산기 작동을 할 수 있다는 뜻



## 3) 메모리

: 컴퓨터 내부의 바이트 저장소라고 생각하면 됨.

- 플립플롭: 메모리의 논리회로 구조이며 NOR게이트 2개의 조합. 1 bit의 정보를 보관, 유지할 수 있는 회로이며, 순차 회로의 기본 요소. 이전 상태를 계속 유지하여 저장함. 종류는 여러가지가 있음. <br>=> 1 bit latch를 n개 붙이면 b bit의 정보를 보관, 유지할 수 있게 됨.<br>=> 정보를 저장할 수 있게 되며, '위치(address)'를 기억하는 것이 중요하게 됨.

**8-to-1 selector?* - 8개 중 1개의 비트를 선택하여 읽을 수 있음.

**3-to-8 decoder?* - 8개 중 1개의 비트를 선택하여 저장할 수 있음.<br>=> 위 두가지를 함께 구성하여 8개의 latch 중 한 곳에 해당하는 주소(address)를 만들 수 있고, 해당 위치에 정보를 저장, 출력할 수 있게 됨.<br>==> 이 온전한 8 bit latch가 바로 RAM(Random Access Memory). 그러나 이 사이즈로는 부족하다.<br>===> 8X1 RAM 2개를 엮으면 8X2 RAM, 1-to-2 decoder를 하나 더 엮으면 16X2 RAM...<br>====> 이런식으로 m*n RAM array를 만들 수 있음.



## 4) 누산기

: 컴퓨터의 CPU에서 중간 산술 논리장치 결과가 저장되는 레지스터.

- 레지스터: CPU 안의 일시 저장장치(1 Cycle)<br>

  ![register](..\..\images\register-165554697586511.PNG)

**<u>=> 각 저장장치마다 접근시간이 다르기 때문에, 필요한 데이터를 어느 위치에 두고 처리하는 지에 따라서 처리 속도가 달라짐!!</u>**

**Assembly 언어?* - CPU에 가장 가깝게 작동하는 저급언어. (기계어와 일대일 대응이 됨)



## 5) 디지털 컴퓨터와 프로그래밍

### - 프로그램 카운터

: 16-bit Counter, 클럭이 1씩 생길때마다 counter가 1씩 증가하는 조합논리회로.<br>Clear 스위치와 함께 회로를 구성하여 저장된 값도 깨끗하게 비울 수 있음.<br>=> 이를 통해 순차적으로 코드를 하나씩 실행시키는 것이 바로 <u>프로그래밍</u> (우리가 작성하는 코드가 위에서부터 아래로, 왼쪽에서부터 오른쪽으로 순차적으로 읽히도록 역할을 하는 것)

### - 프로그래밍

- 명령어(Operation code): Load, Add, Store 등,,, (intel X86, ARM 아키텍처 등)

- Data와 Code를 분리된 각각의 메모리 공간에 저장하여 사용. Operation code(명령어)를 주소(코드)에 할당해 놓고, 주소를 입력하면 Operation code가 실행되게끔 하여 동작시킴.

- Operation code를 하나 하나 다 아는 것은 복잡하고 양이 많기 때문에, 고급언어를 사용하고 컴파일러를 통해 저급언어로 바꾸어 컴퓨터를 동작시키는 방법을 사용하고 있음.

  **컴파일러* - 고급 언어로 작성된 코드를 한번에 기계어로 변환하는 프로그램. Java, C 등..<br>=> 미리 변환하기 때문에 실행 시 기계어로 변환하는 과정이 필요없어 인터프리터 언어보다 빠름. 대신 컴파일과정에서 오류가 발생할 수 있음.

  **인터프리터* - 고급 언어로 작성된 코드를 한줄씩 기계어로 변환하는 프로그램. Python, PHP 등..<br>=> 실행 시 변환하기 때문에 컴파일 에러가 없지만 실행에 시간이 컴파일언어보다 느림.

### - 레지스터

: CPU에 있는 저장공간. 가장 가깝기 때문에 빠른 실행이 가능함.

- PC(Program Counter) : 다음 실행할 명령어 주소를 가리키는 레지스터.
- IR(Instruction Register) : 가장 최근에 인출한 명령어 보관 레지스터.
- 누산기(Acc, Accumulator) : 데이터 일시 보관 레지스터.
- MAR(Memory Address Register) : CPU가 메모리 참조를 위해 보관하는 데이터 주소를 가진 레지스터.
- MBR(Memory Buffer Register) : CPU가 메모리로부터 읽거나, 저장할 데이터 자체를 보관하는 레지스터.



## 6) CPU 파이프라인과 구조

: 모든 명령은 CPU에서 실행할 때 어떤 순차적인 단계를 거친다.<br>(1-Instruction Fetch, 2-Instruction Decode, 3-Instruction Execution, 4-Write Back)<br>=> 그러나 모든 명령을 순차적으로 거칠 때, 다른 단계는 놀고 있기 때문에 비효율이 발생. <br>==> 파이프라인: CPU의 성능을 높이는 기법!

### - 파이프 라인

: 하나의 작업이 필요한 일을 세부적으로 나누어서 동시에 다른 세부작업을 실행하는 기법.![pip](..\..\images\pip.PNG)

**CPU게이트와 인텔의 보안 패치?* - 인텔이 보안이슈가 있어서 패치를 진행하였는데, 성능이 많이 저하되었음. 이유는, 파이프라인 거의 끝에서 보안이슈를 검토하고, 이슈가 생기면 전체 취소가 되었기 때문.(줄 서서 실행하고 있던 코드들이 다 취소가 되어 그만큼 비효율이 발생)

### - CISC, RISC

- CISC(Complex Instruction Set Computer, Intel 방식, PC, 노트북에도 사용)<br>: 조금 더 복잡한 명령을 하나의 명령어 실행으로 실행할 수 있게 함. <br>=> CPU 로직 회로가 복잡해짐<br>=> 하나의 명령어 실행 시간이 증가하고, 명령어마다의 복잡도가 다르기 때문에 실행시간이 달라질 수 있음. 즉, 전체 명령이 얼마나 걸릴지 가늠하기가 어려워짐.
- RISC(Reduced Instruction Set Computer, ARM방식, 모바일, 임베디드, IoT 등)<br>:간단한 명령어를 조합하여 사용하게 함.<br>=> 복잡도는 줄어드나 코드가 굉장히 길어질 수 있음.

------

> 마지막 수정일시: 2022-06-18 21:38